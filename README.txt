Общий концепт:
Язык программирования MSIPL (от Modular Spaceships In-game Programming Language) существует для того, чтобы игроки могли программировать свои космические корабли в Modular Spaceships 2.
Представляет из себя смесь assembly и C. На данный момент код состоит из инструкций, выполняющихся по очереди, а для условных конструкций предусмотрен jump.
Однако, язык проддерживает выражения, переменные и ряд типов данных, некоторые инструкции записываются в виде "функций", а для удаления ссылок на уничтоженные детали корабля предусмотрен сборщик мусора.
Код "компилируется" в массив экземпляров абстрактного класса MSIPL.Instruction, предусмотрены комментарии (начинаются с #) и пустые строки, не входящие в массив.
Скомпилированный код выполняется в детали "процессор" по кругу каждый кадр если процессор включен. При ошибке компиляции или выполнения процессор мгновенно отключается.
Кроме того, для реализации структур данных (например, массивов) предусмотрена деталь "ячейка памяти", которая может хранить массив значений независимо от их типа.
Для записи деталей в переменные предусмотрен механизм их подключения. При этом перезаписать значение в переменной с "подключенной" деталью нельзя чтобы эту деталь нельзя было потерять.


Переменные:
MSIPL предусматривает четыре типа переменных: целочисленный (int), с плавающей запятой (float), логический (bool) и деталь (part)
Переменную можно создать, сразу проинициализировав, а также перезаписать значение в ней.
Для объявления переменной используется инструкция var <type> <name> <value>
Имя переменной - любая строка из латинских букв, цифр и нижних подчёркиваний, не являющаяся числом или true/false, значение - любое выражение, которое может содержать переменные.
Если указать имя переменной в фигурных скобках, то после инициализации её значение нельзя будет изменить.
Для перезаписи значение в переменной используется инструкция set <name> <value> где name - имя существующей переменной, а value - выражение.
Несмотря на то, что тип переменной в MSIPL постоянен, в большинстве случаев значение выражения приводится к нужному типу, в том числе в var и set.

Пример:
var float {pi} 3.14
var int num 42
var float num1 1.9
var bool flag true
#num = 44
set num num+num1
#num = 24
set num1 num-20
#flag = false
set flag false
#flag = true
set flag num1

Поскольку на данный момент работа с переменными неудобна, в будущем планируется более простой синтаксис через "равно", аналогичный C.


jump:
MSIPL предусматривает инструкцию jump <label> <cond> для реализации условных и цикличесикх конструкций, где label - название метки, на которую надо перепрыгнуть, а cond - выражение, которое возвращает bool.
Для объвления метки достаточно написать label <name>, что создаст переменную с типом "метка", доступную только для чтения и использования в jump. Объявление метки не входит в массив инструкций.
Пример:
var int n 10
var int fact 1
var int i 1
#Начало цикла
label start
set n n+1
set fact fact*n
#Конец цикла
jump start i<n
#В итоге fact = 10!

Инструкция jump позволяет реализовать такие конструкции, как if, else, while, операторы break и continue.
В будущем планируется возможность писать эти конструкции также, как и в C. При этом "компилироваться" они будут в те же самые jump'ы.


Ввод-вывод:
В MSIPL предусмотрен ряд функций для использования чата в качестве консоли.
Чтобы ввести первое сообщение из чата, используется функция console read() (на данный момент не реализована из-за отсутствия чата).
console означает, что вызывается функция, связанная с консолью, а read - непосредственно чтение.
Таким образом console read() припишет первое сообщение в чате к потоку ввода, в следующий раз - второе, в третий - третье и так далее.
По умолчанию читаются только сообщения управляющего этим кораблём.
Если сообщений нет, появится ошибка и процессор больше не будет работать.

Поток ввода представляет из себя строку, из которой можно извлекать числа (int и double) и коды символов (в int). Извлекается первое попавшееся значение.
Число вводится функцией console pop() <name> где name это название переменной, в которую записывается число.
При несовпадении типов name и введённого значения произойдёт конвертация, так что bool можно ввести как 0/1.
Для ввода символа надо написать console pop() <name> где name это целочисленная переменная, название которой пишется в одинарных кавычках.

Пример:
[Сообщение]
abc10 2.71eaef1gtf
[Код]
var int num 0
var float e 0
var bool flag false
#Поток ввода - "abc10 2.71eaef1gtf"
console read()
#Поток ввода - "bc10 2.71eaef1gtf", num - 97 (код символа "a")
console pop() 'num'
#Поток ввода - " 2.71eaef1gtf", num - 10 (введённое число)
console pop() num
#Поток ввода - "eaef1gtf", e - 2.71 (введённое число)
console pop() e
#Поток ввода - "gtf", flag = true = 1
console pop() flag
#Поток ввода очищен
console clear_in()

Кроме потока ввода существует поток вывода.
К нему можно приписать значение переменной или выражения (конвертированное в число), символ или заранее известную строку.
Для этого существует console push(<args>) где args это все значения, приписываемые к потоку вывода, разделённые запятыми.
Выражения/переменные указываются как обычно, символ - целочисленная переменная в одинарных кавычках, как в pop, строка - в двойных кавычках.
Чтобы вывести поток вывода надо написать console write() (на данный момент вывод происходит в консоль отладки Unity).

Пример:
var float {pi} 3.14
var int char 41
#Поток вывода - "pi is equal to 3.14"
console push("pi is equal to ", pi)
#Сообщение выведено
console write()
#Поток вывода очищен
console clear_out()
#Поток вывода - "ASCII code of A is 41"
console push("ASCII code of ", 'char', " is ", char)
#Сообщение выведено
console write()
#Поток вывода очищен
console clear_out()

Сообщения от процессора: "pi is equal to 3.14", "ASCII code of A is 41"

Кроме того, можно проверить возможность ввода при помощи console can_pop(<dest>) <name>
dest может быть названием переменной с соответствующим типом.
Если тип dest - bool или part, то он интерпретируется как int.
Целочисленная переменная в одинарных кавычках интерпретируется как символ аналогично предыдущим инструкциям.
name это название булевой переменной, в которую записывется результат проверки.

Пример:
[Сообщение]
10.4A
[Код]
var int char 0
var float val 0
var bool flag false
var bool check false
#Поток ввода - "10.4A"
console read()
#check = true, так как в потоке есть число
console can_pop(val) check
#Поток ввода - "A", val = 10.4
console pop() val
#check = false, так как в потоке ввода нет целых чисел
console can_pop(flag) check
#check = true, так как в потоке остался символ
console can_pop('char') check
#Поток ввода пустой, char = 41 (код A)
console pop() 'char'
#check = false, так как в потоке не осталось символов
console can_pop('char') check

В дальнейшем, после добавления чата, планируется реализовать функции read и write, а также добавить способ фильтровать отправителей и получателей сообщений.


Работа с памятью:
Как я уже говорил, логика MS2 содержит детали, называемые "ячейками памяти". В них можно хранить переменные любого типа, даже нескольких одновременно.
Ячейка работает как массив: есть набор адресов, по каждому из которых можно прочитать/записать значение.
Адрес это целое число от 0 до n где n это количество адресов. Количество адресов в ячейке называется её размером.

После подключения ячейки к процессору, с ней можно работать через инструкцию memory.
Как и в console, далее надо указать что требуется сделать с ячейкой, после этого, в скобках, - аргументы, после - переменную для возвращаемого значения если есть.
Отличием будет необходимость указать саму ячейку через точку (ячейка.действие), где в качестве ячейки испольузется переменная.

Базовые действия с памятью - чтение (get) и запись (set).
Пример (заполняет ячейку последовательностью Фибоначи и выводит последнее):
[Ячейка mem подключена]

var int a 1
var int b 1
var int c 2
var int adr 2
var int size 0

#Получение размера ячейки, на данный момент не реализовано
prop get(mem.memory.size) size
memory mem.set(0, 1)
memory mem.set(1, 1)

label start
memory mem.get(adr-2) a
memory mem.get(adr-1) b
set c a+b
memory mem.set(adr, c)
set adr adr+1
jump start adr<size

console push(c)
console write()
console clear_out()

Также реализованы функции memory clear(<adr>) для записи null по данному адресу и memory get_type(<adr>) <dest> для записи типа значения по заданному адресу в целочисленную переменную.


Прочее:
Кроме всего вышеперечисленного, язык поддерживает инструкцию time с функциями frames_since_launch, seconds_since_launch, delta_time и wait
В дальнейшем планируется добавление инструкций prop и invoke для работы со свойствами и методами деталей, а также так называемый "C-подобный синтаксис"
Он включает в себя то, о чём было сказано в разделах "переменные" и "jump", а также добавление собственных функций.
После реализации всего вышеперечисленного планируется создание и поддержка каталога общедоступных функций, которые любой игрок сможет вставить и использовать.
